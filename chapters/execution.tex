\section{Theory}
\def \kapitelautor {Christoph Führer}
% TODO explain technical theory

\section{Technologies}
\def \kapitelautor {Christoph Führer}
% TODO explain used technologies

\section{Planning and Prototyping} % PoC
\def \kapitelautor {Erik Ritschl}

Our work already began in the summer of 2015. Since Python was a new language to all of us, and we had especially little experience with wxPython and GUI programming in general, we decided this was the best time to acquaint ourselves with these topics. So we read and watched many tutorials on the Internet, until we felt comfortable about carrying out a project with them.

A mini-prototype was also created, as a proof of concept. It had a very minimalistic graphical user interface, and was capable of the following:

\begin{itemize}
	\item Read tags from a database file
	\item Read relations between tags and files
	\item Create folders for tags
	\item Create symbolic links in these folders that point to the according file
\end{itemize}

In this phase, another feature was also planned, as a must-requirement even, that had to be dropped. The software was supposed to be able to save tags not only in the central database file, but also in the meta information of the file itself. Attempts have been made at implementing this functionality, first with EXIF, then IPTC and lastly XMP (all different kinds of meta data, where the first two only work with images and the last one with all files). But it quickly became evident during development of the prototype that there is no easy way to modify meta data with Python on all the platforms that we support (Windows, OS X and Ubuntu).
\paragraph{}
After the summer holidays had ended, the team sat together and decided upon the exact features the software should have. These were then formulated as user stories and together composed the product backlog. Soon after that, a method called \href{https://en.wikipedia.org/wiki/Planning_poker}{Planning Poker} was used in order to decide how many points each user story should be assigned. These points are used to describe the complexity of a user story, and help estimating the total time a task needs in order to be completed.

\paragraph{}
With the completion of the product backlog, the next logical step was to develop a paper prototype. A section of the frontend was assigned to each team member, who subsequently drew sketches with a pen and paper. These were then discussed with the team, and the process was repeated until everyone was happy with the end result.

% TODO: embed sketches, explain frontend


% TODO chronological order
% function prototypes, learning python
% product backlog
% planning poker
% paper prototype
% code snippets

\section{Structure}
\def \kapitelautor {Clemens Stadlbauer}

In our code repository there are several folders, each of which containing a
certain category of files.

\begin{itemize}
	\item[\tfpath{doc/}] The documentation of the software, i.e. the user manual
	\item[\tfpath{icons/}] All the different icons and the logo used throughout the
	software
	\item[\tfpath{db/}] Database schemas and the database setup script
	\item[\tfpath{src/}] The actual code of the software
\end{itemize}

\subsection{db}
In \tfpath{system.sql} is the schema of the main database. It contains the user
settings and the location of all the galleries. Every gallery has its own
database as described in \tfpath{gallery.sql} containing all imported files,
all created tags and all created output folders. The connections between these
items (for example which tags a files has) are recorded in addition,
intermediate tables.

Furthermore, the directory contains a helper script to create the initial
system database and an empty gallery database which is copied every time a new
gallery is created by the user.

\subsection{src}
Herein lie all the modules that make up the entirety of the functionality and
design of OctoTagger. Each module is contained in a single file with the
module's name and can be categorizes as either frontend or backend. All the
frontend modules provide some part of the user interface while all the backend
modules implement mostly all the functionality that happens in the background
(for example the management of files).

% TODO module tree?

\section{Frontend}
%\input{chapters/execution/module.tex}
\section{Backend}
%\input{chapters/execution/module.tex}
% TODO explain code
% each module has a small abstract explaining what and how it works
% each module explained roughly in chronological order

\section{Corporate Design}
%\input{chapters/execution/cd.tex}
% TODO message -> colors
\section{Website}
%\input{chapters/execution/website.tex}
% TODO like module

\section{Quality Management}
\def \kapitelautor {Julian Lorenz}
% TODO
