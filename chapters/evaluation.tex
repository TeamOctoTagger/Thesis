\section{Goals}
\def\kapitelautor{Julian Lorenz}
\subsection{Mandatory Goals}

All of the mandatory goals have been implemented.

\begin{description}
\item [RE-M 1: Cross Platform] Windows, Linux and Mac OS are supported. \checkmark
\item [RE-M 2: Assign Tags to Files] \checkmark
\item [RE-M 3: No Redundant Storage] Symbolic links avoid redundant storage. \checkmark
\item [RE-M 4: Tags as Output Folder] Those output folders can be created with the help of gallery folders. \checkmark
\item [RE-M 5: Complex Queries] Advanced output folders can directly be created out of a search query. \checkmark
\item [RE-M 6: Tag Suggestions] \checkmark
\item [RE-M 7: Public Licence] GPLv3 \checkmark
\item [RE-M 8: Documentation] A user manual has been created as PDF. \checkmark
\item [RE-M 9: Website] \url{http://octotagger.co} \checkmark
\item [RE-M 10: English] OctoTagger UI, Website and Documentation in English. \checkmark
\end{description}


\subsection{Optional Goals}

None of the optional goal could be fulfilled.

\begin{description}
\item [\st{RE-O 1: Numerical Tags}]
\item [\st{RE-O 2: Content Based Suggestions}] 
\item [\st{RE-O 3: Store Tags in Images}] 
\item [\st{RE-O 4: Export and Import Tags}] 

\end{description}


\section{Lessons Learned}
\def\kapitelautor{}

\subsection{Erik Ritschl}
It was an interesting experience to work on, and especially lead, a project of this scale. Some people think the role of leader is an easy one, since ``all you have to do'' is to tell others what they should be working on, which is, of course, not true at all. As project manager, one must always have an overview of what is happening and what needs to be done next. One of the most important tasks is to properly communicate with the team what the plan is, and what role each member plays in it. In other words, delegating is also a lot of hard work, with which I have a lot more experience now.

Planning processes are also not to be taken lightly. We spent many hours drawing sketches of the user interface, crafting prototypes and creating user stories. 
Nevertheless, not every single feature was planned in advance. Some things simply did not occur to us before, and only became clear once we actually had a mostly usable version of the software in our hands. For example, none of us thought about the case of a user editing an image after its thumbnail had only been generated. I only realized the need of a \emph{Refresh thumbnail} function when I actually edited an image. What I did, then, was implementing the feature right away. However, we never discussed it and I think I failed to properly communicate the change to the team. It was also not reflected as a task in \emph{Taiga}, our project management tool. This is something I will definitely handle better in any future projects.

\emph{Taiga} overall caused some confusion for us. It is a very handy tool for tracking progress and assigning tasks, but we only included must-requirements as user stories, because we wanted the burn down chart to reflect our progress on them. We had many optional goals, many of which we did not complete, and they would have made it look like we were much more behind than we actually were. In the future, the features offered or not offered by a planning tool should be inspected more closely, and either the planning process needs to be adapted to it or another tool should be used.

On the matter of presentations, there was one very clear lesson, among others: Always test it under the same conditions under which you will present. We used a web tool for creating our slides (\url{https://slides.com/}), and exported it to a local file on the day before the presentation. And we completely forgot that the local version still used some resources on the internet, which led to some missing images in the Wi-Fi free presentation room. Personally, I will not use this tool again, as it caused too many problems.

But for me, the most important thing I learned is that programming is really a lot of fun. It feels great to build a solution for a problem no one else has solved, and being free to add any feature you want. I am proud of this project, and I am motivated to keep working on and expanding upon OctoTagger.

\subsection{Clemens Stadlbauer}

I have learned quite a lot about the pitfalls a project can have while working
on OctoTagger. The most important aspect, to me at least, is the continuous
ensurance of quality. Defining a small set of absolutely mandatory goals at the
beginning that capture the vision of the project, creating a functional
prototype that tests all requirements and writing automated tests to prevent
regressions from happening.

Having a clear vision from the start discourages implementing features which do
not align with this vision. We did not have such a fixed vision and I noticed
from time to time newly implemented features that seemed a bit out of place
because everyone had their own idea of what the software should do. The source
code as well should be structured so that it represents the vision resulting
in a module tree that represents how the product functions. For OctoTagger we
did not define a module layout and now we have just a bunch of files that are
difficult to manage.

Each external technology a program uses can break in unexpected ways. For this
reason a prototype is crafted, to see if all technologies really do solve our
problems instead of introducing new ones. I always though a prototype only has
to test functionality but there is one more aspect it must have: it must fulfill
all the requirements of the project. For OctoTagger a prototype showing that
managing tagged files is possible was created but some assumptions, mainly about
symlinks on Windows, were made that have not been clearly defined in the
contract. Had we not made assumptions here we would have saved a lot of time.

During development bugs appeared, which we anticipated, but as we neared
project completion fixing bugs became more difficult due to everything being
fragile. Fixing one bug resulted in breaking multiple other, previously working
parts of the software. Most of these regression bugs were in the frontend
because none of us are experts in wxWidgets but it nonetheless showed me the
importance of pinning down correct behavior with a test.

Finally, as soon as multiple people work on a project and some form of
collaboration is required I noticed that it is really important that everyone
understand the collaboration tools used, which are in our case \emph{Taiga},
\emph{GitHub} and \emph{Git}. If someone doesn't know how to use one of
these tools and makes a mistake, everyone suffers from this mistake!

\subsection{Christoph FÃ¼hrer}

\paragraph{}
I have learned a lot about how fragile a project, especially a software project, can be. Small misconceptions between team members and their vision about the final product can be followed by severe consequences. While every member of the team had a similar idea of how OctoTagger should look like in the end, everyone still had some different opinions, concepts and ways of how we should proceed to the implementation. This could be reasoned by saying that we lacked an accurate planning. It could also be said that we did not communicate enough about how everybody wanted the end product to look like. While this is partly true from my perspective, I also believe that we just had a lack in the amount of research we did in the summer. Furthermore, everybody researched something else and we did not compare appropriately what has been found out. So when we started developing the software everybody was on a different level of knowledge and generally just not on equal ground. This is where many of the misconceptions came from in my opinion.  

Doing an extensive amount of research is just that important, especially when working with technologies completely unfamiliar to someone (In our case: Python, wxWidgets, PIL,\ldots). I cannot even imagine how much of a better planning phase we could have had if we had just added a few hours of research and comparison to everybody's tasks. The Windows Symlink problem (chapter 4, Implementation, pywinlink) for example this task far exceeded our expectation and therefore was planned to take about a fifth of the time it eventually took us. This led to an unexpected shift of working time, tasks and a change of the whole module structure which could have been prevented by doing proper research. While this was probably the biggest case of lacking research there were multiple more scenarios where it could have helped by a tremendous amount.

All in all, a lack of research always goes hand in hand with a lack of experience. If one is experienced enough he does not have to research as much as one who is not. However, I do not believe that we were at fault for not being experienced enough. We chose to go a path where we had to learn ourselves a lot of new things. We knew that we had a deficiency of experience in many matters and that we would have to research a lot on our own. The fact that we neglected this a little bit gave us a lot of trouble which could have been prevented easily.

\paragraph{}
Furthermore, I learned that setting goals is extremely important. Not just setting goals for the team or the product but for yourself. While having a goal which has to be fulfilled at the end of the task, like a definition of done, is a necessary thing too, it is not the only goal that should be set in my opinion. If one plans a clear goal of what he wants to have done at the end of a block of work, his efficiency will rise by a great amount. On the other hand, if one works on a task day for day without defining what he wants to be done after each block of work he will not feel satisfied with what he has done until the whole task is eventually finished. Having a clear vision of what you want to achieve at the end of the day can help making the work so much more efficient, effective and entertaining.

\subsection{Julian Lorenz}

One of the lessons I have learned is how easy it is to underestimate the effort for software development. One reason for that was the missing experience with the used technologies. In addition testing, finding bugs and fixing them took a lot more time than expected. Our initial goal to fully test the software every week could not be reached due to lack of time. Because of the fact that OctoTagger is a cross platform application, differences between supported operating systems have also been underestimated.

This project taught me how important communication between team members is. For example changes in the software were added ad hoc and sometimes have not been communicated to all members. Additional face to face meetings could have improved outcome, as some misunderstandings could have been avoided.

Developing the OctoTagger website showed me the importance of testing on different devices, browsers and operating systems as soon as possible. Testing on a different computer could have avoided unnecessary platform specific mistakes.

Another experience I have made during web development is that tiny mistakes (e.g. typos) can lead to long hours of bug tracking. So before doing long research on the internet, it's sometimes helpful to inspect the source code properly for such kind of mistakes. Often the proposed solution in online forums are misleading and can result in long fruitless activities.
