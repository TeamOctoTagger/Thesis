\section{Goals}

\section{Lessons Learned}
\def\kapitelautor{}

\subsection{Erik Ritschl}
It was an interesting experience to work on, and especially lead, a project of this scale. Some people think the role of leader is an easy one, since ``all you have to do'' is to tell others what they should be working on, which is, of course, not true at all. As project manager, one must always have an overview of what is happening and what needs to be done next. One of the most important tasks is to properly communicate with the team what the plan is, and what role each member plays in it. In other words, delegating is also a lot of hard work, with which I have a lot more experience now.

Planning processes are also not to be taken lightly. We spent many hours drawing sketches of the user interface, crafting prototypes and creating user stories. 
Nevertheless, not every single feature was planned in advance. Some things simply did not occur to us before, and only became clear once we actually had a mostly usable version of the software in our hands. For example, none of us thought about the case of a user editing an image after its thumbnail had only been generated. I only realized the need of a \emph{Refresh thumbnail} function when I actually edited an image. What I did, then, was implementing the feature right away. However, we never discussed it and I think I failed to properly communicate the change to the team. It was also not reflected as a task in \emph{Taiga}, our project management tool. This is something I will definitely handle better in any future projects.

\emph{Taiga} overall caused some confusion for us. It is a very handy tool for tracking progress and assigning tasks, but we only included must-requirements as user stories, because we wanted the burn down chart to reflect our progress on them. We had many optional goals, many of which we did not complete, and they would have made it look like we were much more behind than we actually were. In the future, the features offered or not offered by a planning tool should be inspected more closely, and either the planning process needs to be adapted to it or another tool should be used.

On the matter of presentations, there was one very clear lesson, among others: Always test it under the same conditions under which you will present. We used a web tool for creating our slides (\url{https://slides.com/}), and exported it to a local file on the day before the presentation. And we completely forgot that the local version still used some resources on the internet, which led to some missing images in the Wi-Fi free presentation room. Personally, I will not use this tool again, as it caused too many problems.

But for me, the most important thing I learned is that programming is really a lot of fun. It feels great to build a solution for a problem no one else has solved, and being free to add any feature you want. I am proud of this project, and I am motivated to keep working on and expanding upon OctoTagger.

\subsection{Clemens Stadlbauer}

I have learned quite a lot about the pitfalls a project can have while working
on OctoTagger. The most important aspect, to me at least, is the continuous
ensurance of quality. Defining a small set of absolutely mandatory goals at the
beginning that capture the vision of the project, creating a functional
prototype that tests all requirements and writing automated tests to prevent
regressions from happening.

Having a clear vision from the start discourages implementing features which do
not align with this vision. We did not have such a fixed vision and I noticed
from time to time newly implemented features that seemed a bit out of place
because everyone had their own idea of what the software should do. The source
code as well should be structured so that it represents the vision resulting
in a module tree that represents how the product functions. For OctoTagger we
did not define a module layout and now we have just a bunch of files that are
difficult to manage.

Each external technology a program uses can break in unexpected ways. For this
reason a prototype is crafted, to see if all technologies really do solve our
problems instead of introducing new ones. I always though a prototype only has
to test functionality but there is one more aspect it must have: it must fulfill
all the requirements of the project. For OctoTagger a prototype showing that
managing tagged files is possible was created but some assumptions, mainly about
symlinks on Windows, were made that have not been clearly defined in the
contract. Had we not made assumptions here we would have saved a lot of time.

During development bugs appeared, which we anticipated, but as we neared
project completion fixing bugs became more difficult due to everything being
fragile. Fixing one bug resulted in breaking multiple other, previously working
parts of the software. Most of these regression bugs were in the frontend
because none of us are experts in wxWidgets but it nonetheless showed me the
importance of pinning down correct behavior with a test.

\subsection{Christoph FÃ¼hrer}
\subsection{Julian Lorenz}

\section{Summary}
